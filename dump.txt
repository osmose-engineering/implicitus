============================= test session starts ==============================
platform darwin -- Python 3.13.5, pytest-8.4.1, pluggy-1.6.0
rootdir: /Users/danielgonzalez/Dropbox (Personal)/concepts/osmose/R&D/implicit/implicitus
configfile: pytest.ini
plugins: anyio-4.9.0
collected 6 items

tests/ai_adapter/test_csg_adapter.py ...FFF                              [100%]

=================================== FAILURES ===================================
__________________________ test_parse_infill_modifier __________________________

self = <google.protobuf.json_format._Parser object at 0x104bb8550>
js = {'infill': {'density': 0.5, 'pattern': 'hex'}, 'primitive': {'box': {'size': {'x': 12.0, 'y': 12.0, 'z': 12.0}}}}
message = primitive {
  box {
    size {
      x: 12
      y: 12
      z: 12
    }
  }
}

path = 'Model.root'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
>             raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
E             google.protobuf.json_format.ParseError: Message type "implicitus.Node" should not have multiple "body" oneof fields at "Model.root".

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:609: ParseError

The above exception was the direct cause of the following exception:

self = <google.protobuf.json_format._Parser object at 0x104bb8550>
js = {'id': '0cc2be08-3654-4b8f-b79a-c58417489d66', 'root': {'infill': {'density': 0.5, 'pattern': 'hex'}, 'primitive': {'box': {'size': {'x': 12.0, 'y': 12.0, 'z': 12.0}}}}}
message = id: "0cc2be08-3654-4b8f-b79a-c58417489d66"
root {
  primitive {
    box {
      size {
        x: 12
        y: 12
        z: 12
      }
    }
  }
}

path = 'Model'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
              raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
            names.append(oneof_name)
    
          if value is None:
            if (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE
                and field.message_type.full_name == 'google.protobuf.Value'
            ):
              sub_message = getattr(message, field.name)
              sub_message.null_value = 0
            elif (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                and field.enum_type.full_name == 'google.protobuf.NullValue'
            ):
              setattr(message, field.name, 0)
            else:
              message.ClearField(field.name)
            continue
    
          # Parse field value.
          if _IsMapEntry(field):
            message.ClearField(field.name)
            self._ConvertMapFieldValue(
                value, message, field, '{0}.{1}'.format(path, name)
            )
          elif field.label == descriptor.FieldDescriptor.LABEL_REPEATED:
            message.ClearField(field.name)
            if not isinstance(value, _LIST_LIKE):
              raise ParseError(
                  'repeated field {0} must be in [] which is {1} at {2}'.format(
                      name, value, path
                  )
              )
            if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
              # Repeated message field.
              for index, item in enumerate(value):
                sub_message = getattr(message, field.name).add()
                # None is a null_value in Value.
                if (
                    item is None
                    and sub_message.DESCRIPTOR.full_name
                    != 'google.protobuf.Value'
                ):
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self.ConvertMessage(
                    item, sub_message, '{0}.{1}[{2}]'.format(path, name, index)
                )
            else:
              # Repeated scalar field.
              for index, item in enumerate(value):
                if item is None:
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self._ConvertAndAppendScalar(
                  message, field, item, '{0}.{1}[{2}]'.format(path, name, index))
          elif field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
            if field.is_extension:
              sub_message = message.Extensions[field]
            else:
              sub_message = getattr(message, field.name)
            sub_message.SetInParent()
>           self.ConvertMessage(value, sub_message, '{0}.{1}'.format(path, name))

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:684: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:540: in ConvertMessage
    self._ConvertFieldValuePair(value, message, path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <google.protobuf.json_format._Parser object at 0x104bb8550>
js = {'infill': {'density': 0.5, 'pattern': 'hex'}, 'primitive': {'box': {'size': {'x': 12.0, 'y': 12.0, 'z': 12.0}}}}
message = primitive {
  box {
    size {
      x: 12
      y: 12
      z: 12
    }
  }
}

path = 'Model.root'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
              raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
            names.append(oneof_name)
    
          if value is None:
            if (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE
                and field.message_type.full_name == 'google.protobuf.Value'
            ):
              sub_message = getattr(message, field.name)
              sub_message.null_value = 0
            elif (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                and field.enum_type.full_name == 'google.protobuf.NullValue'
            ):
              setattr(message, field.name, 0)
            else:
              message.ClearField(field.name)
            continue
    
          # Parse field value.
          if _IsMapEntry(field):
            message.ClearField(field.name)
            self._ConvertMapFieldValue(
                value, message, field, '{0}.{1}'.format(path, name)
            )
          elif field.label == descriptor.FieldDescriptor.LABEL_REPEATED:
            message.ClearField(field.name)
            if not isinstance(value, _LIST_LIKE):
              raise ParseError(
                  'repeated field {0} must be in [] which is {1} at {2}'.format(
                      name, value, path
                  )
              )
            if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
              # Repeated message field.
              for index, item in enumerate(value):
                sub_message = getattr(message, field.name).add()
                # None is a null_value in Value.
                if (
                    item is None
                    and sub_message.DESCRIPTOR.full_name
                    != 'google.protobuf.Value'
                ):
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self.ConvertMessage(
                    item, sub_message, '{0}.{1}[{2}]'.format(path, name, index)
                )
            else:
              # Repeated scalar field.
              for index, item in enumerate(value):
                if item is None:
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self._ConvertAndAppendScalar(
                  message, field, item, '{0}.{1}[{2}]'.format(path, name, index))
          elif field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
            if field.is_extension:
              sub_message = message.Extensions[field]
            else:
              sub_message = getattr(message, field.name)
            sub_message.SetInParent()
            self.ConvertMessage(value, sub_message, '{0}.{1}'.format(path, name))
          else:
            if field.is_extension:
              self._ConvertAndSetScalarExtension(message, field, value, '{0}.{1}'.format(path, name))
            else:
              self._ConvertAndSetScalar(message, field, value, '{0}.{1}'.format(path, name))
        except ParseError as e:
          if field and field.containing_oneof is None:
            raise ParseError(
                'Failed to parse {0} field: {1}.'.format(name, e)
            ) from e
          else:
>           raise ParseError(str(e)) from e
E           google.protobuf.json_format.ParseError: Message type "implicitus.Node" should not have multiple "body" oneof fields at "Model.root".

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:696: ParseError

The above exception was the direct cause of the following exception:

    def test_parse_infill_modifier():
        raw = '{"shape":"box","size_mm":12,"infill":{"pattern":"hex","density":0.5}}'
>       model = csg_adapter.parse_and_build_model(raw)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/ai_adapter/test_csg_adapter.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
ai_adapter/csg_adapter.py:83: in parse_and_build_model
    json_format.ParseDict(model_dict, proto)
../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:494: in ParseDict
    parser.ConvertMessage(js_dict, message, '')
../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:540: in ConvertMessage
    self._ConvertFieldValuePair(value, message, path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <google.protobuf.json_format._Parser object at 0x104bb8550>
js = {'id': '0cc2be08-3654-4b8f-b79a-c58417489d66', 'root': {'infill': {'density': 0.5, 'pattern': 'hex'}, 'primitive': {'box': {'size': {'x': 12.0, 'y': 12.0, 'z': 12.0}}}}}
message = id: "0cc2be08-3654-4b8f-b79a-c58417489d66"
root {
  primitive {
    box {
      size {
        x: 12
        y: 12
        z: 12
      }
    }
  }
}

path = 'Model'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
              raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
            names.append(oneof_name)
    
          if value is None:
            if (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE
                and field.message_type.full_name == 'google.protobuf.Value'
            ):
              sub_message = getattr(message, field.name)
              sub_message.null_value = 0
            elif (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                and field.enum_type.full_name == 'google.protobuf.NullValue'
            ):
              setattr(message, field.name, 0)
            else:
              message.ClearField(field.name)
            continue
    
          # Parse field value.
          if _IsMapEntry(field):
            message.ClearField(field.name)
            self._ConvertMapFieldValue(
                value, message, field, '{0}.{1}'.format(path, name)
            )
          elif field.label == descriptor.FieldDescriptor.LABEL_REPEATED:
            message.ClearField(field.name)
            if not isinstance(value, _LIST_LIKE):
              raise ParseError(
                  'repeated field {0} must be in [] which is {1} at {2}'.format(
                      name, value, path
                  )
              )
            if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
              # Repeated message field.
              for index, item in enumerate(value):
                sub_message = getattr(message, field.name).add()
                # None is a null_value in Value.
                if (
                    item is None
                    and sub_message.DESCRIPTOR.full_name
                    != 'google.protobuf.Value'
                ):
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self.ConvertMessage(
                    item, sub_message, '{0}.{1}[{2}]'.format(path, name, index)
                )
            else:
              # Repeated scalar field.
              for index, item in enumerate(value):
                if item is None:
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self._ConvertAndAppendScalar(
                  message, field, item, '{0}.{1}[{2}]'.format(path, name, index))
          elif field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
            if field.is_extension:
              sub_message = message.Extensions[field]
            else:
              sub_message = getattr(message, field.name)
            sub_message.SetInParent()
            self.ConvertMessage(value, sub_message, '{0}.{1}'.format(path, name))
          else:
            if field.is_extension:
              self._ConvertAndSetScalarExtension(message, field, value, '{0}.{1}'.format(path, name))
            else:
              self._ConvertAndSetScalar(message, field, value, '{0}.{1}'.format(path, name))
        except ParseError as e:
          if field and field.containing_oneof is None:
>           raise ParseError(
                'Failed to parse {0} field: {1}.'.format(name, e)
            ) from e
E           google.protobuf.json_format.ParseError: Failed to parse root field: Message type "implicitus.Node" should not have multiple "body" oneof fields at "Model.root"..

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:692: ParseError
______________________ test_parse_boolean_operation_union ______________________

self = <google.protobuf.json_format._Parser object at 0x104ba1220>, js = 'union'
message = , path = 'Model.root.booleanOp'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
>           raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
E           google.protobuf.json_format.ParseError: Message type "implicitus.BooleanOp" has no field named "u" at "Model.root.booleanOp".
E            Available Fields(except extensions): "['union', 'difference', 'intersection']"

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:585: ParseError

The above exception was the direct cause of the following exception:

self = <google.protobuf.json_format._Parser object at 0x104ba1220>
js = {'booleanOp': 'union', 'children': [{'primitive': {'sphere': {'radius': 2.5}}}, {'primitive': {'box': {'size': {'x': 5.0, 'y': 5.0, 'z': 5.0}}}}]}
message = boolean_op {
}
, path = 'Model.root'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
              raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
            names.append(oneof_name)
    
          if value is None:
            if (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE
                and field.message_type.full_name == 'google.protobuf.Value'
            ):
              sub_message = getattr(message, field.name)
              sub_message.null_value = 0
            elif (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                and field.enum_type.full_name == 'google.protobuf.NullValue'
            ):
              setattr(message, field.name, 0)
            else:
              message.ClearField(field.name)
            continue
    
          # Parse field value.
          if _IsMapEntry(field):
            message.ClearField(field.name)
            self._ConvertMapFieldValue(
                value, message, field, '{0}.{1}'.format(path, name)
            )
          elif field.label == descriptor.FieldDescriptor.LABEL_REPEATED:
            message.ClearField(field.name)
            if not isinstance(value, _LIST_LIKE):
              raise ParseError(
                  'repeated field {0} must be in [] which is {1} at {2}'.format(
                      name, value, path
                  )
              )
            if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
              # Repeated message field.
              for index, item in enumerate(value):
                sub_message = getattr(message, field.name).add()
                # None is a null_value in Value.
                if (
                    item is None
                    and sub_message.DESCRIPTOR.full_name
                    != 'google.protobuf.Value'
                ):
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self.ConvertMessage(
                    item, sub_message, '{0}.{1}[{2}]'.format(path, name, index)
                )
            else:
              # Repeated scalar field.
              for index, item in enumerate(value):
                if item is None:
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self._ConvertAndAppendScalar(
                  message, field, item, '{0}.{1}[{2}]'.format(path, name, index))
          elif field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
            if field.is_extension:
              sub_message = message.Extensions[field]
            else:
              sub_message = getattr(message, field.name)
            sub_message.SetInParent()
>           self.ConvertMessage(value, sub_message, '{0}.{1}'.format(path, name))

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:684: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:540: in ConvertMessage
    self._ConvertFieldValuePair(value, message, path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <google.protobuf.json_format._Parser object at 0x104ba1220>, js = 'union'
message = , path = 'Model.root.booleanOp'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
              raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
            names.append(oneof_name)
    
          if value is None:
            if (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE
                and field.message_type.full_name == 'google.protobuf.Value'
            ):
              sub_message = getattr(message, field.name)
              sub_message.null_value = 0
            elif (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                and field.enum_type.full_name == 'google.protobuf.NullValue'
            ):
              setattr(message, field.name, 0)
            else:
              message.ClearField(field.name)
            continue
    
          # Parse field value.
          if _IsMapEntry(field):
            message.ClearField(field.name)
            self._ConvertMapFieldValue(
                value, message, field, '{0}.{1}'.format(path, name)
            )
          elif field.label == descriptor.FieldDescriptor.LABEL_REPEATED:
            message.ClearField(field.name)
            if not isinstance(value, _LIST_LIKE):
              raise ParseError(
                  'repeated field {0} must be in [] which is {1} at {2}'.format(
                      name, value, path
                  )
              )
            if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
              # Repeated message field.
              for index, item in enumerate(value):
                sub_message = getattr(message, field.name).add()
                # None is a null_value in Value.
                if (
                    item is None
                    and sub_message.DESCRIPTOR.full_name
                    != 'google.protobuf.Value'
                ):
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self.ConvertMessage(
                    item, sub_message, '{0}.{1}[{2}]'.format(path, name, index)
                )
            else:
              # Repeated scalar field.
              for index, item in enumerate(value):
                if item is None:
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self._ConvertAndAppendScalar(
                  message, field, item, '{0}.{1}[{2}]'.format(path, name, index))
          elif field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
            if field.is_extension:
              sub_message = message.Extensions[field]
            else:
              sub_message = getattr(message, field.name)
            sub_message.SetInParent()
            self.ConvertMessage(value, sub_message, '{0}.{1}'.format(path, name))
          else:
            if field.is_extension:
              self._ConvertAndSetScalarExtension(message, field, value, '{0}.{1}'.format(path, name))
            else:
              self._ConvertAndSetScalar(message, field, value, '{0}.{1}'.format(path, name))
        except ParseError as e:
          if field and field.containing_oneof is None:
            raise ParseError(
                'Failed to parse {0} field: {1}.'.format(name, e)
            ) from e
          else:
>           raise ParseError(str(e)) from e
E           google.protobuf.json_format.ParseError: Message type "implicitus.BooleanOp" has no field named "u" at "Model.root.booleanOp".
E            Available Fields(except extensions): "['union', 'difference', 'intersection']"

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:696: ParseError

The above exception was the direct cause of the following exception:

self = <google.protobuf.json_format._Parser object at 0x104ba1220>
js = {'id': 'f42fd4bf-f1fb-4f89-851a-8cab09ff7d87', 'root': {'booleanOp': 'union', 'children': [{'primitive': {'sphere': {'radius': 2.5}}}, {'primitive': {'box': {'size': {...}}}}]}}
message = id: "f42fd4bf-f1fb-4f89-851a-8cab09ff7d87"
root {
  boolean_op {
  }
}

path = 'Model'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
              raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
            names.append(oneof_name)
    
          if value is None:
            if (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE
                and field.message_type.full_name == 'google.protobuf.Value'
            ):
              sub_message = getattr(message, field.name)
              sub_message.null_value = 0
            elif (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                and field.enum_type.full_name == 'google.protobuf.NullValue'
            ):
              setattr(message, field.name, 0)
            else:
              message.ClearField(field.name)
            continue
    
          # Parse field value.
          if _IsMapEntry(field):
            message.ClearField(field.name)
            self._ConvertMapFieldValue(
                value, message, field, '{0}.{1}'.format(path, name)
            )
          elif field.label == descriptor.FieldDescriptor.LABEL_REPEATED:
            message.ClearField(field.name)
            if not isinstance(value, _LIST_LIKE):
              raise ParseError(
                  'repeated field {0} must be in [] which is {1} at {2}'.format(
                      name, value, path
                  )
              )
            if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
              # Repeated message field.
              for index, item in enumerate(value):
                sub_message = getattr(message, field.name).add()
                # None is a null_value in Value.
                if (
                    item is None
                    and sub_message.DESCRIPTOR.full_name
                    != 'google.protobuf.Value'
                ):
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self.ConvertMessage(
                    item, sub_message, '{0}.{1}[{2}]'.format(path, name, index)
                )
            else:
              # Repeated scalar field.
              for index, item in enumerate(value):
                if item is None:
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self._ConvertAndAppendScalar(
                  message, field, item, '{0}.{1}[{2}]'.format(path, name, index))
          elif field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
            if field.is_extension:
              sub_message = message.Extensions[field]
            else:
              sub_message = getattr(message, field.name)
            sub_message.SetInParent()
>           self.ConvertMessage(value, sub_message, '{0}.{1}'.format(path, name))

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:684: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:540: in ConvertMessage
    self._ConvertFieldValuePair(value, message, path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <google.protobuf.json_format._Parser object at 0x104ba1220>
js = {'booleanOp': 'union', 'children': [{'primitive': {'sphere': {'radius': 2.5}}}, {'primitive': {'box': {'size': {'x': 5.0, 'y': 5.0, 'z': 5.0}}}}]}
message = boolean_op {
}
, path = 'Model.root'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
              raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
            names.append(oneof_name)
    
          if value is None:
            if (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE
                and field.message_type.full_name == 'google.protobuf.Value'
            ):
              sub_message = getattr(message, field.name)
              sub_message.null_value = 0
            elif (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                and field.enum_type.full_name == 'google.protobuf.NullValue'
            ):
              setattr(message, field.name, 0)
            else:
              message.ClearField(field.name)
            continue
    
          # Parse field value.
          if _IsMapEntry(field):
            message.ClearField(field.name)
            self._ConvertMapFieldValue(
                value, message, field, '{0}.{1}'.format(path, name)
            )
          elif field.label == descriptor.FieldDescriptor.LABEL_REPEATED:
            message.ClearField(field.name)
            if not isinstance(value, _LIST_LIKE):
              raise ParseError(
                  'repeated field {0} must be in [] which is {1} at {2}'.format(
                      name, value, path
                  )
              )
            if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
              # Repeated message field.
              for index, item in enumerate(value):
                sub_message = getattr(message, field.name).add()
                # None is a null_value in Value.
                if (
                    item is None
                    and sub_message.DESCRIPTOR.full_name
                    != 'google.protobuf.Value'
                ):
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self.ConvertMessage(
                    item, sub_message, '{0}.{1}[{2}]'.format(path, name, index)
                )
            else:
              # Repeated scalar field.
              for index, item in enumerate(value):
                if item is None:
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self._ConvertAndAppendScalar(
                  message, field, item, '{0}.{1}[{2}]'.format(path, name, index))
          elif field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
            if field.is_extension:
              sub_message = message.Extensions[field]
            else:
              sub_message = getattr(message, field.name)
            sub_message.SetInParent()
            self.ConvertMessage(value, sub_message, '{0}.{1}'.format(path, name))
          else:
            if field.is_extension:
              self._ConvertAndSetScalarExtension(message, field, value, '{0}.{1}'.format(path, name))
            else:
              self._ConvertAndSetScalar(message, field, value, '{0}.{1}'.format(path, name))
        except ParseError as e:
          if field and field.containing_oneof is None:
            raise ParseError(
                'Failed to parse {0} field: {1}.'.format(name, e)
            ) from e
          else:
>           raise ParseError(str(e)) from e
E           google.protobuf.json_format.ParseError: Message type "implicitus.BooleanOp" has no field named "u" at "Model.root.booleanOp".
E            Available Fields(except extensions): "['union', 'difference', 'intersection']"

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:696: ParseError

The above exception was the direct cause of the following exception:

    def test_parse_boolean_operation_union():
        raw = '{"primitives":[{"shape":"sphere","size_mm":5},{"shape":"box","size_mm":5}],"boolean":"union"}'
>       model = csg_adapter.parse_and_build_model(raw)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/ai_adapter/test_csg_adapter.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
ai_adapter/csg_adapter.py:83: in parse_and_build_model
    json_format.ParseDict(model_dict, proto)
../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:494: in ParseDict
    parser.ConvertMessage(js_dict, message, '')
../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:540: in ConvertMessage
    self._ConvertFieldValuePair(value, message, path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <google.protobuf.json_format._Parser object at 0x104ba1220>
js = {'id': 'f42fd4bf-f1fb-4f89-851a-8cab09ff7d87', 'root': {'booleanOp': 'union', 'children': [{'primitive': {'sphere': {'radius': 2.5}}}, {'primitive': {'box': {'size': {...}}}}]}}
message = id: "f42fd4bf-f1fb-4f89-851a-8cab09ff7d87"
root {
  boolean_op {
  }
}

path = 'Model'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
              raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
            names.append(oneof_name)
    
          if value is None:
            if (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE
                and field.message_type.full_name == 'google.protobuf.Value'
            ):
              sub_message = getattr(message, field.name)
              sub_message.null_value = 0
            elif (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                and field.enum_type.full_name == 'google.protobuf.NullValue'
            ):
              setattr(message, field.name, 0)
            else:
              message.ClearField(field.name)
            continue
    
          # Parse field value.
          if _IsMapEntry(field):
            message.ClearField(field.name)
            self._ConvertMapFieldValue(
                value, message, field, '{0}.{1}'.format(path, name)
            )
          elif field.label == descriptor.FieldDescriptor.LABEL_REPEATED:
            message.ClearField(field.name)
            if not isinstance(value, _LIST_LIKE):
              raise ParseError(
                  'repeated field {0} must be in [] which is {1} at {2}'.format(
                      name, value, path
                  )
              )
            if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
              # Repeated message field.
              for index, item in enumerate(value):
                sub_message = getattr(message, field.name).add()
                # None is a null_value in Value.
                if (
                    item is None
                    and sub_message.DESCRIPTOR.full_name
                    != 'google.protobuf.Value'
                ):
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self.ConvertMessage(
                    item, sub_message, '{0}.{1}[{2}]'.format(path, name, index)
                )
            else:
              # Repeated scalar field.
              for index, item in enumerate(value):
                if item is None:
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self._ConvertAndAppendScalar(
                  message, field, item, '{0}.{1}[{2}]'.format(path, name, index))
          elif field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
            if field.is_extension:
              sub_message = message.Extensions[field]
            else:
              sub_message = getattr(message, field.name)
            sub_message.SetInParent()
            self.ConvertMessage(value, sub_message, '{0}.{1}'.format(path, name))
          else:
            if field.is_extension:
              self._ConvertAndSetScalarExtension(message, field, value, '{0}.{1}'.format(path, name))
            else:
              self._ConvertAndSetScalar(message, field, value, '{0}.{1}'.format(path, name))
        except ParseError as e:
          if field and field.containing_oneof is None:
>           raise ParseError(
                'Failed to parse {0} field: {1}.'.format(name, e)
            ) from e
E           google.protobuf.json_format.ParseError: Failed to parse root field: Message type "implicitus.BooleanOp" has no field named "u" at "Model.root.booleanOp".
E            Available Fields(except extensions): "['union', 'difference', 'intersection']".

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:692: ParseError
________________ test_parse_invalid_boolean_without_primitives _________________

self = <google.protobuf.json_format._Parser object at 0x104ba1f30>
js = 'difference', message = , path = 'Model.root.booleanOp'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
>           raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
E           google.protobuf.json_format.ParseError: Message type "implicitus.BooleanOp" has no field named "d" at "Model.root.booleanOp".
E            Available Fields(except extensions): "['union', 'difference', 'intersection']"

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:585: ParseError

The above exception was the direct cause of the following exception:

self = <google.protobuf.json_format._Parser object at 0x104ba1f30>
js = {'booleanOp': 'difference', 'children': [{'primitive': {'sphere': {'radius': 2.0}}}]}
message = boolean_op {
}
, path = 'Model.root'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
              raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
            names.append(oneof_name)
    
          if value is None:
            if (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE
                and field.message_type.full_name == 'google.protobuf.Value'
            ):
              sub_message = getattr(message, field.name)
              sub_message.null_value = 0
            elif (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                and field.enum_type.full_name == 'google.protobuf.NullValue'
            ):
              setattr(message, field.name, 0)
            else:
              message.ClearField(field.name)
            continue
    
          # Parse field value.
          if _IsMapEntry(field):
            message.ClearField(field.name)
            self._ConvertMapFieldValue(
                value, message, field, '{0}.{1}'.format(path, name)
            )
          elif field.label == descriptor.FieldDescriptor.LABEL_REPEATED:
            message.ClearField(field.name)
            if not isinstance(value, _LIST_LIKE):
              raise ParseError(
                  'repeated field {0} must be in [] which is {1} at {2}'.format(
                      name, value, path
                  )
              )
            if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
              # Repeated message field.
              for index, item in enumerate(value):
                sub_message = getattr(message, field.name).add()
                # None is a null_value in Value.
                if (
                    item is None
                    and sub_message.DESCRIPTOR.full_name
                    != 'google.protobuf.Value'
                ):
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self.ConvertMessage(
                    item, sub_message, '{0}.{1}[{2}]'.format(path, name, index)
                )
            else:
              # Repeated scalar field.
              for index, item in enumerate(value):
                if item is None:
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self._ConvertAndAppendScalar(
                  message, field, item, '{0}.{1}[{2}]'.format(path, name, index))
          elif field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
            if field.is_extension:
              sub_message = message.Extensions[field]
            else:
              sub_message = getattr(message, field.name)
            sub_message.SetInParent()
>           self.ConvertMessage(value, sub_message, '{0}.{1}'.format(path, name))

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:684: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:540: in ConvertMessage
    self._ConvertFieldValuePair(value, message, path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <google.protobuf.json_format._Parser object at 0x104ba1f30>
js = 'difference', message = , path = 'Model.root.booleanOp'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
              raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
            names.append(oneof_name)
    
          if value is None:
            if (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE
                and field.message_type.full_name == 'google.protobuf.Value'
            ):
              sub_message = getattr(message, field.name)
              sub_message.null_value = 0
            elif (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                and field.enum_type.full_name == 'google.protobuf.NullValue'
            ):
              setattr(message, field.name, 0)
            else:
              message.ClearField(field.name)
            continue
    
          # Parse field value.
          if _IsMapEntry(field):
            message.ClearField(field.name)
            self._ConvertMapFieldValue(
                value, message, field, '{0}.{1}'.format(path, name)
            )
          elif field.label == descriptor.FieldDescriptor.LABEL_REPEATED:
            message.ClearField(field.name)
            if not isinstance(value, _LIST_LIKE):
              raise ParseError(
                  'repeated field {0} must be in [] which is {1} at {2}'.format(
                      name, value, path
                  )
              )
            if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
              # Repeated message field.
              for index, item in enumerate(value):
                sub_message = getattr(message, field.name).add()
                # None is a null_value in Value.
                if (
                    item is None
                    and sub_message.DESCRIPTOR.full_name
                    != 'google.protobuf.Value'
                ):
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self.ConvertMessage(
                    item, sub_message, '{0}.{1}[{2}]'.format(path, name, index)
                )
            else:
              # Repeated scalar field.
              for index, item in enumerate(value):
                if item is None:
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self._ConvertAndAppendScalar(
                  message, field, item, '{0}.{1}[{2}]'.format(path, name, index))
          elif field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
            if field.is_extension:
              sub_message = message.Extensions[field]
            else:
              sub_message = getattr(message, field.name)
            sub_message.SetInParent()
            self.ConvertMessage(value, sub_message, '{0}.{1}'.format(path, name))
          else:
            if field.is_extension:
              self._ConvertAndSetScalarExtension(message, field, value, '{0}.{1}'.format(path, name))
            else:
              self._ConvertAndSetScalar(message, field, value, '{0}.{1}'.format(path, name))
        except ParseError as e:
          if field and field.containing_oneof is None:
            raise ParseError(
                'Failed to parse {0} field: {1}.'.format(name, e)
            ) from e
          else:
>           raise ParseError(str(e)) from e
E           google.protobuf.json_format.ParseError: Message type "implicitus.BooleanOp" has no field named "d" at "Model.root.booleanOp".
E            Available Fields(except extensions): "['union', 'difference', 'intersection']"

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:696: ParseError

The above exception was the direct cause of the following exception:

self = <google.protobuf.json_format._Parser object at 0x104ba1f30>
js = {'id': '7270379a-91d8-4eab-834a-43cfc60f2d45', 'root': {'booleanOp': 'difference', 'children': [{'primitive': {'sphere': {'radius': 2.0}}}]}}
message = id: "7270379a-91d8-4eab-834a-43cfc60f2d45"
root {
  boolean_op {
  }
}

path = 'Model'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
              raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
            names.append(oneof_name)
    
          if value is None:
            if (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE
                and field.message_type.full_name == 'google.protobuf.Value'
            ):
              sub_message = getattr(message, field.name)
              sub_message.null_value = 0
            elif (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                and field.enum_type.full_name == 'google.protobuf.NullValue'
            ):
              setattr(message, field.name, 0)
            else:
              message.ClearField(field.name)
            continue
    
          # Parse field value.
          if _IsMapEntry(field):
            message.ClearField(field.name)
            self._ConvertMapFieldValue(
                value, message, field, '{0}.{1}'.format(path, name)
            )
          elif field.label == descriptor.FieldDescriptor.LABEL_REPEATED:
            message.ClearField(field.name)
            if not isinstance(value, _LIST_LIKE):
              raise ParseError(
                  'repeated field {0} must be in [] which is {1} at {2}'.format(
                      name, value, path
                  )
              )
            if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
              # Repeated message field.
              for index, item in enumerate(value):
                sub_message = getattr(message, field.name).add()
                # None is a null_value in Value.
                if (
                    item is None
                    and sub_message.DESCRIPTOR.full_name
                    != 'google.protobuf.Value'
                ):
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self.ConvertMessage(
                    item, sub_message, '{0}.{1}[{2}]'.format(path, name, index)
                )
            else:
              # Repeated scalar field.
              for index, item in enumerate(value):
                if item is None:
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self._ConvertAndAppendScalar(
                  message, field, item, '{0}.{1}[{2}]'.format(path, name, index))
          elif field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
            if field.is_extension:
              sub_message = message.Extensions[field]
            else:
              sub_message = getattr(message, field.name)
            sub_message.SetInParent()
>           self.ConvertMessage(value, sub_message, '{0}.{1}'.format(path, name))

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:684: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:540: in ConvertMessage
    self._ConvertFieldValuePair(value, message, path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <google.protobuf.json_format._Parser object at 0x104ba1f30>
js = {'booleanOp': 'difference', 'children': [{'primitive': {'sphere': {'radius': 2.0}}}]}
message = boolean_op {
}
, path = 'Model.root'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
              raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
            names.append(oneof_name)
    
          if value is None:
            if (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE
                and field.message_type.full_name == 'google.protobuf.Value'
            ):
              sub_message = getattr(message, field.name)
              sub_message.null_value = 0
            elif (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                and field.enum_type.full_name == 'google.protobuf.NullValue'
            ):
              setattr(message, field.name, 0)
            else:
              message.ClearField(field.name)
            continue
    
          # Parse field value.
          if _IsMapEntry(field):
            message.ClearField(field.name)
            self._ConvertMapFieldValue(
                value, message, field, '{0}.{1}'.format(path, name)
            )
          elif field.label == descriptor.FieldDescriptor.LABEL_REPEATED:
            message.ClearField(field.name)
            if not isinstance(value, _LIST_LIKE):
              raise ParseError(
                  'repeated field {0} must be in [] which is {1} at {2}'.format(
                      name, value, path
                  )
              )
            if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
              # Repeated message field.
              for index, item in enumerate(value):
                sub_message = getattr(message, field.name).add()
                # None is a null_value in Value.
                if (
                    item is None
                    and sub_message.DESCRIPTOR.full_name
                    != 'google.protobuf.Value'
                ):
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self.ConvertMessage(
                    item, sub_message, '{0}.{1}[{2}]'.format(path, name, index)
                )
            else:
              # Repeated scalar field.
              for index, item in enumerate(value):
                if item is None:
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self._ConvertAndAppendScalar(
                  message, field, item, '{0}.{1}[{2}]'.format(path, name, index))
          elif field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
            if field.is_extension:
              sub_message = message.Extensions[field]
            else:
              sub_message = getattr(message, field.name)
            sub_message.SetInParent()
            self.ConvertMessage(value, sub_message, '{0}.{1}'.format(path, name))
          else:
            if field.is_extension:
              self._ConvertAndSetScalarExtension(message, field, value, '{0}.{1}'.format(path, name))
            else:
              self._ConvertAndSetScalar(message, field, value, '{0}.{1}'.format(path, name))
        except ParseError as e:
          if field and field.containing_oneof is None:
            raise ParseError(
                'Failed to parse {0} field: {1}.'.format(name, e)
            ) from e
          else:
>           raise ParseError(str(e)) from e
E           google.protobuf.json_format.ParseError: Message type "implicitus.BooleanOp" has no field named "d" at "Model.root.booleanOp".
E            Available Fields(except extensions): "['union', 'difference', 'intersection']"

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:696: ParseError

The above exception was the direct cause of the following exception:

    def test_parse_invalid_boolean_without_primitives():
        # Boolean specified but no primitives list provided should still wrap root element
        raw = '{"shape":"sphere","size_mm":4,"boolean":"difference"}'
>       model = csg_adapter.parse_and_build_model(raw)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/ai_adapter/test_csg_adapter.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
ai_adapter/csg_adapter.py:83: in parse_and_build_model
    json_format.ParseDict(model_dict, proto)
../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:494: in ParseDict
    parser.ConvertMessage(js_dict, message, '')
../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:540: in ConvertMessage
    self._ConvertFieldValuePair(value, message, path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <google.protobuf.json_format._Parser object at 0x104ba1f30>
js = {'id': '7270379a-91d8-4eab-834a-43cfc60f2d45', 'root': {'booleanOp': 'difference', 'children': [{'primitive': {'sphere': {'radius': 2.0}}}]}}
message = id: "7270379a-91d8-4eab-834a-43cfc60f2d45"
root {
  boolean_op {
  }
}

path = 'Model'

    def _ConvertFieldValuePair(self, js, message, path):
      """Convert field value pairs into regular message.
    
      Args:
        js: A JSON object to convert the field value pairs.
        message: A regular protocol message to record the data.
        path: parent path to log parse error info.
    
      Raises:
        ParseError: In case of problems converting.
      """
      names = []
      message_descriptor = message.DESCRIPTOR
      fields_by_json_name = dict(
          (f.json_name, f) for f in message_descriptor.fields
      )
      for name in js:
        try:
          field = fields_by_json_name.get(name, None)
          if not field:
            field = message_descriptor.fields_by_name.get(name, None)
          if not field and _VALID_EXTENSION_NAME.match(name):
            if not message_descriptor.is_extendable:
              raise ParseError(
                  'Message type {0} does not have extensions at {1}'.format(
                      message_descriptor.full_name, path
                  )
              )
            identifier = name[1:-1]  # strip [] brackets
            # pylint: disable=protected-access
            field = message.Extensions._FindExtensionByName(identifier)
            # pylint: enable=protected-access
            if not field:
              # Try looking for extension by the message type name, dropping the
              # field name following the final . separator in full_name.
              identifier = '.'.join(identifier.split('.')[:-1])
              # pylint: disable=protected-access
              field = message.Extensions._FindExtensionByName(identifier)
              # pylint: enable=protected-access
          if not field:
            if self.ignore_unknown_fields:
              continue
            raise ParseError(
                (
                    'Message type "{0}" has no field named "{1}" at "{2}".\n'
                    ' Available Fields(except extensions): "{3}"'
                ).format(
                    message_descriptor.full_name,
                    name,
                    path,
                    [f.json_name for f in message_descriptor.fields],
                )
            )
          if name in names:
            raise ParseError(
                'Message type "{0}" should not have multiple '
                '"{1}" fields at "{2}".'.format(
                    message.DESCRIPTOR.full_name, name, path
                )
            )
          names.append(name)
          value = js[name]
          # Check no other oneof field is parsed.
          if field.containing_oneof is not None and value is not None:
            oneof_name = field.containing_oneof.name
            if oneof_name in names:
              raise ParseError(
                  'Message type "{0}" should not have multiple '
                  '"{1}" oneof fields at "{2}".'.format(
                      message.DESCRIPTOR.full_name, oneof_name, path
                  )
              )
            names.append(oneof_name)
    
          if value is None:
            if (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE
                and field.message_type.full_name == 'google.protobuf.Value'
            ):
              sub_message = getattr(message, field.name)
              sub_message.null_value = 0
            elif (
                field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_ENUM
                and field.enum_type.full_name == 'google.protobuf.NullValue'
            ):
              setattr(message, field.name, 0)
            else:
              message.ClearField(field.name)
            continue
    
          # Parse field value.
          if _IsMapEntry(field):
            message.ClearField(field.name)
            self._ConvertMapFieldValue(
                value, message, field, '{0}.{1}'.format(path, name)
            )
          elif field.label == descriptor.FieldDescriptor.LABEL_REPEATED:
            message.ClearField(field.name)
            if not isinstance(value, _LIST_LIKE):
              raise ParseError(
                  'repeated field {0} must be in [] which is {1} at {2}'.format(
                      name, value, path
                  )
              )
            if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
              # Repeated message field.
              for index, item in enumerate(value):
                sub_message = getattr(message, field.name).add()
                # None is a null_value in Value.
                if (
                    item is None
                    and sub_message.DESCRIPTOR.full_name
                    != 'google.protobuf.Value'
                ):
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self.ConvertMessage(
                    item, sub_message, '{0}.{1}[{2}]'.format(path, name, index)
                )
            else:
              # Repeated scalar field.
              for index, item in enumerate(value):
                if item is None:
                  raise ParseError(
                      'null is not allowed to be used as an element'
                      ' in a repeated field at {0}.{1}[{2}]'.format(
                          path, name, index
                      )
                  )
                self._ConvertAndAppendScalar(
                  message, field, item, '{0}.{1}[{2}]'.format(path, name, index))
          elif field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:
            if field.is_extension:
              sub_message = message.Extensions[field]
            else:
              sub_message = getattr(message, field.name)
            sub_message.SetInParent()
            self.ConvertMessage(value, sub_message, '{0}.{1}'.format(path, name))
          else:
            if field.is_extension:
              self._ConvertAndSetScalarExtension(message, field, value, '{0}.{1}'.format(path, name))
            else:
              self._ConvertAndSetScalar(message, field, value, '{0}.{1}'.format(path, name))
        except ParseError as e:
          if field and field.containing_oneof is None:
>           raise ParseError(
                'Failed to parse {0} field: {1}.'.format(name, e)
            ) from e
E           google.protobuf.json_format.ParseError: Failed to parse root field: Message type "implicitus.BooleanOp" has no field named "d" at "Model.root.booleanOp".
E            Available Fields(except extensions): "['union', 'difference', 'intersection']".

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/json_format.py:692: ParseError
=============================== warnings summary ===============================
../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/_pytest/config/__init__.py:1474
  /Users/danielgonzalez/miniforge3/envs/llm/lib/python3.13/site-packages/_pytest/config/__init__.py:1474: PytestConfigWarning: Unknown config option: python_paths
  
    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")

../../../../../../miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/runtime_version.py:98
  /Users/danielgonzalez/miniforge3/envs/llm/lib/python3.13/site-packages/google/protobuf/runtime_version.py:98: UserWarning: Protobuf gencode version 5.29.3 is exactly one major version older than the runtime version 6.31.1 at implicitus.proto. Please update the gencode to avoid compatibility violations in the next runtime release.
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/ai_adapter/test_csg_adapter.py::test_parse_infill_modifier - goo...
FAILED tests/ai_adapter/test_csg_adapter.py::test_parse_boolean_operation_union
FAILED tests/ai_adapter/test_csg_adapter.py::test_parse_invalid_boolean_without_primitives
=================== 3 failed, 3 passed, 2 warnings in 0.15s ====================
